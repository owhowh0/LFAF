# Laboratory Work 1: Regular Grammars and Finite Automata

### Course: Formal Languages & Finite Automata  
### Author: Covali Ilie     

----

## Theory

A formal language is defined by three main components: an alphabet (a set of allowed symbols), a grammar (a set of production rules that describe how valid strings are formed), and the set of all valid strings generated by this grammar. In this work, we focus on regular grammars, which are a special type of grammar where productions have a restricted form, making them equivalent to finite automata.

Finite automata are abstract machines that recognize formal languages by reading an input string symbol by symbol and transitioning between states according to a transition function. A deterministic finite automaton (DFA) is formally defined as a 5-tuple (Q, Σ, δ, q₀, F), where Q is a set of states, Σ is the input alphabet, δ is the transition function, q₀ is the initial state, and F is the set of accepting states. There is a well-known equivalence between regular grammars and finite automata, meaning any regular grammar can be converted into an equivalent DFA.

Regular grammars are important because they describe the simplest class of languages in the Chomsky hierarchy and are practical for designing tokenizers, simple protocol validators, and pattern recognizers. Their restricted production forms guarantee that parsing can be done with finite memory, which is exactly what a finite automaton provides. This tight correspondence makes regular grammars a good starting point for building intuition about how language rules translate into executable recognition logic.

----

## Objectives

* Understand what a formal language is and its components.  
* Implement a regular grammar as a Python class.  
* Generate valid strings from the given grammar.  
* Convert the grammar into an equivalent finite automaton.  
* Implement a method to check whether a string belongs to the language using the automaton.  
* Organize the project in a GitHub repository with a structured report.
* Practice mapping formal definitions to concrete data structures and algorithms.
* Provide examples that show the generator and validator working together.

----

## Implementation Description

### 1. Grammar Representation

The grammar is implemented as a Python class `Grammar` containing the sets of non-terminals, terminals, the start symbol, and the production rules. These components directly correspond to the formal definition of a grammar G = (Vₙ, Vₜ, P, S). The production rules are stored in a dictionary where each non-terminal maps to a list of its possible right-hand sides.

To keep the implementation simple and readable, non-terminals are represented as single uppercase letters and terminals as lowercase letters. This allows the string generator to scan for non-terminals and replace them in a straightforward way without needing a separate token structure. The rules used in this lab are taken directly from the variant definition, so the class is essentially a faithful encoding of the formal grammar.

```python
class Grammar:
    def __init__(self):
        # Non-terminals
        self.VN = {"S", "B", "D", "Q"}
        
        # Terminals
        self.VT = {"a", "b", "c", "d"}

        # Start symbol
        self.S = "S"

        # Production rules
        self.P = {
            "S": ["aB", "bB"],
            "B": ["cD"],
            "D": ["dQ", "a"],
            "Q": ["bB", "dQ"]
        }
```

### 2. String Generation from the Grammar

The `generate_string` method starts from the start symbol and repeatedly replaces one non-terminal with one of its productions until only terminal symbols remain. The replacement is chosen randomly, which allows the generation of different valid strings from the same grammar.

This stochastic approach is useful for quickly checking whether the production rules can produce diverse outputs and for testing the automaton with multiple valid examples. Because the grammar is regular, every replacement either adds one terminal and another non-terminal or ends the derivation with a terminal symbol. The loop stops as soon as no non-terminals remain.

```python
def generate_string(self):
    current = self.S

    while True:
        replaced = False

        for nt in self.VN:
            if nt in current:
                production = self.P[nt]
                chosen = random.choice(production)
                current = current.replace(nt, chosen, 1)
                replaced = True
                break
        
        if not replaced:
            break
    return current
```

### 3. Conversion from Grammar to Finite Automaton

The `toFiniteAutomaton` method converts the regular grammar into an equivalent deterministic finite automaton. Each non-terminal becomes a state, each terminal becomes part of the input alphabet, and each production rule defines a transition. Productions of the form A → aB create a transition from state A to B on symbol a, while productions of the form A → a lead to a special accepting state "ACCEPT".

This conversion mirrors the standard textbook transformation from a right-linear grammar to a DFA. The extra accepting state makes it possible to represent productions that terminate the derivation. By making that state final and including it in the transition table, the resulting automaton stays deterministic and easy to simulate.

```python
def toFiniteAutomaton(self):
    Q = set(self.VN) 
    Sigma = set(self.VT)
    delta = {}
    F = set()

    for A, productions in self.P.items():
        for production in productions:
            if len(production) == 2:
                terminal = production[0]
                non_terminal = production[1]
                if A not in delta:
                    delta[A] = {}
                delta[A][terminal] = non_terminal
            elif len(production) == 1:
                terminal = production
                F.add(A)
                if A not in delta:
                    delta[A] = {}
                delta[A][terminal] = "ACCEPT"

    Q.add("ACCEPT")
    delta["ACCEPT"] = {}

    F.add("ACCEPT")

    return FiniteAutomaton(Q, Sigma, delta, self.S, F)
```

### 4. Finite Automaton Representation

The `FiniteAutomaton` class stores all components of the DFA: states, alphabet, transition function, initial state, and final states. This mirrors the formal definition of a deterministic finite automaton.

The transition function is implemented as a nested dictionary, which provides clear and direct access for each state-symbol pair. This choice keeps the acceptance check efficient and makes it easy to inspect the machine during debugging or printing.

```python
class FiniteAutomaton:
    def __init__(self, Q, Sigma, delta, q0, F):
        self.Q = Q
        self.Sigma = Sigma
        self.delta = delta
        self.q0 = q0
        self.F = F
```

### 5. Checking if a String Belongs to the Language

The `string_belongs_to_language` method simulates the operation of the DFA. It starts from the initial state and follows transitions according to each input symbol. If the automaton ends in an accepting state after reading the entire string, the string is considered valid.

If at any point a transition is missing, the string is immediately rejected, which matches the formal definition of a DFA. This explicit check also makes errors easy to spot when testing with invalid inputs.

```python
def string_belongs_to_language(self, input_string):
    current_state = self.q0

    for symbol in input_string:
        if symbol not in self.delta[current_state]:
            return False
        
        current_state = self.delta[current_state][symbol]
    
    return current_state in self.F
```

----

## Conclusions / Results

In this laboratory work, a regular grammar corresponding to Variant 9 was successfully implemented in Python. A method was created to generate valid strings from the grammar, demonstrating how derivations work in practice. The grammar was then converted into an equivalent finite automaton using a systematic transformation based on theoretical principles.

The implemented finite automaton correctly accepts all valid strings generated by the grammar and rejects invalid ones, which was verified through testing. This confirms the equivalence between regular grammars and finite automata and demonstrates a practical application of formal language theory.

Overall, the lab bridges formal definitions and working code. The generator provides concrete samples of the language, while the automaton validates them in a deterministic way. This dual perspective helps illustrate how syntactic rules become executable recognition procedures and prepares the project structure for later labs where more complex language classes are studied.

----

## References

1. Course materials: Cretu Dumitru, Vasile Drumea, Irina Cojuhari — *Formal Languages & Finite Automata*.  
2. Hopcroft, Motwani, Ullman — *Introduction to Automata Theory, Languages, and Computation*.  
3. Your own implemented Python project (GitHub repository).
