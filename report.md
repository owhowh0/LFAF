# Laboratory Work 1: Regular Grammars and Finite Automata

### Course: Formal Languages & Finite Automata  
### Author: Covali Ilie     

----

## Theory

A formal language is defined by three main components: an alphabet (a set of allowed symbols), a grammar (a set of production rules that describe how valid strings are formed), and the set of all valid strings generated by this grammar. In this work, we focus on regular grammars, which are a special type of grammar where productions have a restricted form, making them equivalent to finite automata.

Finite automata are abstract machines that recognize formal languages by reading an input string symbol by symbol and transitioning between states according to a transition function. A deterministic finite automaton (DFA) is formally defined as a 5-tuple (Q, Σ, δ, q₀, F), where Q is a set of states, Σ is the input alphabet, δ is the transition function, q₀ is the initial state, and F is the set of accepting states. There is a well-known equivalence between regular grammars and finite automata, meaning any regular grammar can be converted into an equivalent DFA.

----

## Objectives

* Understand what a formal language is and its components.  
* Implement a regular grammar as a Python class.  
* Generate valid strings from the given grammar.  
* Convert the grammar into an equivalent finite automaton.  
* Implement a method to check whether a string belongs to the language using the automaton.  
* Organize the project in a GitHub repository with a structured report.

----

## Implementation Description

### 1. Grammar Representation

The grammar is implemented as a Python class `Grammar` containing the sets of non-terminals, terminals, the start symbol, and the production rules. These components directly correspond to the formal definition of a grammar G = (Vₙ, Vₜ, P, S). The production rules are stored in a dictionary where each non-terminal maps to a list of its possible right-hand sides.

```python
class Grammar:
    def __init__(self):
        # Non-terminals
        self.VN = {"S", "B", "D", "Q"}
        
        # Terminals
        self.VT = {"a", "b", "c", "d"}

        # Start symbol
        self.S = "S"

        # Production rules
        self.P = {
            "S": ["aB", "bB"],
            "B": ["cD"],
            "D": ["dQ", "a"],
            "Q": ["bB", "dQ"]
        }
```

### 2. String Generation from the Grammar

The `generate_string` method starts from the start symbol and repeatedly replaces one non-terminal with one of its productions until only terminal symbols remain. The replacement is chosen randomly, which allows the generation of different valid strings from the same grammar.

```python
def generate_string(self):
    current = self.S

    while True:
        replaced = False

        for nt in self.VN:
            if nt in current:
                production = self.P[nt]
                chosen = random.choice(production)
                current = current.replace(nt, chosen, 1)
                replaced = True
                break
        
        if not replaced:
            break
    return current
```

### 3. Conversion from Grammar to Finite Automaton

The `toFiniteAutomaton` method converts the regular grammar into an equivalent deterministic finite automaton. Each non-terminal becomes a state, each terminal becomes part of the input alphabet, and each production rule defines a transition. Productions of the form A → aB create a transition from state A to B on symbol a, while productions of the form A → a lead to a special accepting state "ACCEPT".

```python
def toFiniteAutomaton(self):
    Q = set(self.VN) 
    Sigma = set(self.VT)
    delta = {}
    F = set()

    for A, productions in self.P.items():
        for production in productions:
            if len(production) == 2:
                terminal = production[0]
                non_terminal = production[1]
                if A not in delta:
                    delta[A] = {}
                delta[A][terminal] = non_terminal
            elif len(production) == 1:
                terminal = production
                F.add(A)
                if A not in delta:
                    delta[A] = {}
                delta[A][terminal] = "ACCEPT"

    Q.add("ACCEPT")
    delta["ACCEPT"] = {}

    F.add("ACCEPT")

    return FiniteAutomaton(Q, Sigma, delta, self.S, F)
```

### 4. Finite Automaton Representation

The `FiniteAutomaton` class stores all components of the DFA: states, alphabet, transition function, initial state, and final states. This mirrors the formal definition of a deterministic finite automaton.

```python
class FiniteAutomaton:
    def __init__(self, Q, Sigma, delta, q0, F):
        self.Q = Q
        self.Sigma = Sigma
        self.delta = delta
        self.q0 = q0
        self.F = F
```

### 5. Checking if a String Belongs to the Language

The `string_belongs_to_language` method simulates the operation of the DFA. It starts from the initial state and follows transitions according to each input symbol. If the automaton ends in an accepting state after reading the entire string, the string is considered valid.

```python
def string_belongs_to_language(self, input_string):
    current_state = self.q0

    for symbol in input_string:
        if symbol not in self.delta[current_state]:
            return False
        
        current_state = self.delta[current_state][symbol]
    
    return current_state in self.F
```

----

## Conclusions / Results

In this laboratory work, a regular grammar corresponding to Variant 9 was successfully implemented in Python. A method was created to generate valid strings from the grammar, demonstrating how derivations work in practice. The grammar was then converted into an equivalent finite automaton using a systematic transformation based on theoretical principles.

The implemented finite automaton correctly accepts all valid strings generated by the grammar and rejects invalid ones, which was verified through testing. This confirms the equivalence between regular grammars and finite automata and demonstrates a practical application of formal language theory.

----

## References

1. Course materials: Cretu Dumitru, Vasile Drumea, Irina Cojuhari — *Formal Languages & Finite Automata*.  
2. Hopcroft, Motwani, Ullman — *Introduction to Automata Theory, Languages, and Computation*.  
3. Your own implemented Python project (GitHub repository).
